'use strict';           // jshint ignore: line

// IndexedDB is a browser built-in db. Features:
// * supports some types of keys and almost any types of values
// * supports transactions
// * supports querying keys ranges and indexing
// * allows to store a larger amount of data comparing to the local storage

// IndexedDB is intended for offline applications alongside with ServiceWorkers and other powerful technologies.
// IndexedDB interface is based on the events model. There is a number of wrappers, which make possible to use Promises and await/async mechanism with IndexedDB,
// but there is a number of limitations comparing to the event-based interface.

// There could be a number of databases, but all of them exist and are accessible in the context of a particular source (protocol/domain/port combination).

// To start the IndexedDB usage the particular db should be opened.
const indexedDB = require('indexeddb');         // NodeJS implementation, not verified.
const dbName = 'dbName';
const dbVersion = 2;                            // Db version, 1 by default.
const openRequest = indexedDB.open(dbName, dbVersion);

// Version parameter is used to track db versions. If the requested db version is greater than the existing one or if the db doesn't exist - the 'upgradeneeded' event rises.
// If the requested db version is lesser than the existing one - the 'error' event rises, the current window/tab must be reloaded and stale cache should be destroyed.
// If there is an open tab with some version and the other tab tries to upgrade the db - there 'versionchange' event rises (because it's needed to close all the connections
// to the older db version before upgrading). After the 'versionchange' event if there stays a connection to the older db version - the new connection will be blocked with
// a 'blocked' event ('success' event won't be fired).
openRequest.onupgradeneeded = function(event) {
    // The db initialization or the version upgrade actions are needed.
    const db = openRequest.result;
    switch (db.version) {
        case 0:
            // Db doesn't exist - the initialization is needed.
        case 1:
            // Db version doesn't match - the upgrade is needed.
    }
};
openRequest.onerror = function(event) {
    console.error(`Error: ${openRequest.error}`);
};
openRequest.onsuccess = function(event) {
    // Event is fired after a successful db opening or after a successful upgrade/initialization.
    const db = openRequest.result;
    db.onversionchange = function(event) {
        db.close();     // To prevent the 'blocked' event to be fired.
        alert('Db version changed, please reload the page.');
    };
};
openRequest.onblocked = function(event) {
    console.log('Connection to db failed, there is an open connection to the older db version.');
};

// To delete a db:
const deleteDbRequest = indexedDB.deleteDatabase('dbName');
deleteDbRequest.onerror = function(event) { /* ... */ };
deleteDbRequest.onsuccess = function(event) { /* ... */ };

// To store something in a db - the object store should be created (other databases use the term "a table" or "a collection").
// IndexedDB uses a "standard serialization mechanism" https://www.w3.org/TR/html53/infrastructure.html#section-structuredserializeforstorage. It's like the JSON.stringify(),
// but much more powerful and allows to store much more data types. The objects with cyclic links couldn't be stored - the serialization error will rise in that case.

// IndexedDB supports keys of type: number, date, string, binary, array. A key must be unique of course. The value object's property could be used as a key, or a key could
// be autogenerated with a special mechanism.

// To create an object store:
// db.createObjectStore(name[, keyOptions]);
// Note: this method is synchronous, there is no need to use 'await' or wait for any event upon call.
// * name - the name of the object store
// * keyOptions - the optional object with optional properties:
//      - keyPath - the path of the property, which will be used to autogenerate the key (e.g. 'id')
//      - autoincrement - if true the id will be autogenerated and automatically incremented.
// If a 'keyOptions' argument was skipped - the key should be provided on each object store request.
// An object store could be created only inside 'onupgradeneeded' listener.
openRequest.onupgradeneeded = function(event) {
    const db = openRequest.result;
    // Note: there are two ways to handle db version change:
    // * to get the db version inside the 'onupgradeneeded' listener and to change the db version-to-version.
    // * to get the existing object stores with the [db.objectStoreNames] property of a DOMStringList type and to change the db to match the latest version (used with simpler db).
    if (!db.objectStoreNames.contains('books')) {
        db.createObjectStore('books', { keyPath: 'id' });
    }
    db.deleteObjectStore('books');      // To delete an object store.
};

// All operations in IndexedDB must be performed inside a transaction:
// db.transaction(store[, type]);
// * store - the name of a store
// * type - transaction type, one of:
//      - 'readonly' - default
//      - 'readwrite' - read/write of data is allowed, read/write of stores is denied.
// Actually there is another transaction type 'versionchange', wich allows read/write of stores. But it couldn't be created by a user.
// The db creates that kind of transaction inside the 'updateneeded' listener.
// A 'readwrite' transaction blocks the store for other transactions, 'readonly' doesn't.
openRequest.onsuccess = function(event) {
    const db = openRequest.result;
    const transaction = db.transaction('books', 'readwrite');
    const books = transaction.objectStore('books');
    const book = { id: 'js', price: 10, created: new Date() };
    const request = books.add(book);
    request.onsuccess = function(event) { console.log('Book created', request.result); };
    request.onerror = function(event) { console.error('Book creation error.'); };

    // There are 2 methods to append values to an object store:
    // * put(value, [key]) - add new or change the existing key/value pair.
    // * add(value, [key]) - add new or throw an ConstraintError if the key record exists.
    //  request.result stores a key, request.error - possible error.

    // At the time there is no possibility to finish a transaction 'by hand'. The transaction is being auto-closed when there is no more request to the db and when the
    // microtasks queue is empty. That's why there is no possibility to perform asynchronous operations after the db.transaction(...) call - TransactionInactiveError will arise.

    // The 'complete' event of the transaction object guarantees that a transaction was saved completely.
    transaction.oncomplete = function(event) {
        console.log('Transaction was finished.');
    };

    transaction.abort();                                // To cancel the transaction manually.
    transaction.onabort = function(event) {             // The 'abort' event will be fired after the .abort() method call.
        console.log('Transaction was aborted.');
    };
};


